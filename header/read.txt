c++头文件不必是.h结尾，
C math.h,stdio.h -- cmath cstdio


名字空间 -- namespace 
为防止名字冲突（出现同名），c++引入了名字空间
通过 :: 运算符限定某个名字属于哪个名字空间
如：“计算机1702“ :: “李平”
   “信计1603” :: “李平”


通常有3种方法使用名字空间X的名字name:
1. using namespace X ; 引入X整个名字空间,之后使用就不需要加上名字空间的前缀
2. using X :: name; 使用单个名字，之后可以直接使用name
3. X :: name; 程序中加上名字空间前缀，如X ::

C++中新的输入输出流库（头文件 iostream）将输入输出看成一个流，
并用输出运算符 <<  和 输入运算符 >> 对数据(变量和常量进行输入输出)；

其中有cout 和 cin 分别代表标准输出流对象（屏幕窗口）和 标志输入流对象（键盘）；
相当于 C 的 stdout stdin

标准库中的名字都属于标志名字空间std.

变量“即用即定义”，且可用表达式初始化

程序块{}内部作用域可定义域外部作用域同名的变量，在该块里就屏蔽了外部变量

for 循环语句可以定义局部变量

C++引入了“引用类型”,即一个变量是另一个变量的别名
引用经常用作函数的形参，表示形参和实参是同一个对象，
在函数中对形参的修改也是对实参的修改

引用作为参数传递时，不需要额外的内存开销，值传递需要内存开销
当实参占据内存大的时候，用引用代替传值可提供效率
如果不希望因此无意中修改实参，可以用const修改符。
指针可以偏移，引用不行

对于不包含循环的简单函数，建议用关键字inline声明为“内联函数”
编译器调用到inline时，直接将其代码展开--内联展开，避免函数调用开销，提高程序执行效率；空间换时间
但是编译器不一定会内联展开，会根据实际情况来判断决定

通过try-catch处理异常情况
正常代码放在try块，catch中捕获try块抛出的异常

运算符重载 -- 重新定义运算符的规则(在原有特性基础上)
重新定义的格式 -- 关键字 operator * + - / <<
vector2 operator *(double a, vector2 b)

template 可以对任何能比较大小(<)的类型使用该模板让编译器
自动生成一个针对该数据类型的具体函数


类的成员函数，可以返回自身的引用
类的成员函数肯定是通过类的对象来调用它的
在C++中，函数返回类型后面的 & 符号表示该函数返回一个引用（reference）。
具体来说，Date& add(int dd) 表示 add 函数返回一个对 Date 对象的引用。


构造函数是和类名同名且没有返回类型的函数，在定义对象时会自动被调用，而不需要在单独调
用专门的初始化函数如init，
构造函数用于初始化类对象成员，包括申请一些资源，如分配内存、打开某文件等
可以有多个构造函数（参数类型不同）



析构函数是在类对象销毁时被自动调用，用于释放该对象占用的资源，如释放占用的内存、关闭
打开的文件


class成员默认是私有的
struct成员默认是公开的
接口：public的公开成员（一般是成员函数）称为这个类的对外接口，外部函数只能通过这些接
口访问类对象，
private等非public的包含内部内部细节，不对外公开，从而可以封装保护类对象！


student m(s)
s = k
一般的类，如果没有定义拷贝构造函数、赋值运算符函数，编译器会自动帮我们生成（硬拷贝）
拷贝构造函数：定义一个类对象时用同类型的另外对象初始化
赋值运算符：一个对象赋值给另外一个对象


student s; //默认初始化
//student k((char*)"John",56);
//cout << k.name << ", age " << k.age <<endl;

student m(s);//定义了一个m,用s来构造它 -- 拷贝构造函数(编译器自动生成)
//s = k; //赋值运算符（编译器自动生成）
//用编译器自动生成的可能会出错
cout << s.name << ", age " << s.age << endl<<endl;
cout << m.name << ", age " << m.age << endl<<endl;

构造函数,申请了100个char元素的动态空间
no_name, age 0

no_name, age 0

构造函数,释放了100个char元素的动态空间
copy(28179,0x1dc9cdec0) malloc: Double free of object 0x141f04080
copy(28179,0x1dc9cdec0) malloc: *** set a breakpoint in malloc_error_break to debug
zsh: abort      ./copy

为什么没有调用两次构造函数？
    //delete[] m.name     delete[] s.name 
    //两个name指向同一块内存 -- 硬拷贝 （直接复制值）
    //释放完m后，又会释放s;即，会对同一块内存重复释放 -- 出错



迭代器（iterator）是一个对象，能够遍历容器（如数组、向量、链表等）中的元素。
迭代器类似于指针，但更灵活，因为它们可以在不同类型的容器之间工作。
const_iterator 允许遍历容器中的元素，但不允许修改这些元素。


vector 是一个类模板

Inheritance继承(Derivation派生)： 一个派生类(derived class)
从1个或多个父类(parent class) / 基类(base class)继承，即继承父类的属性和行为，
但也有自己的特有属性和行为

派生函数不能直接初始化基类的成员，只能初始化自己的属性（这个不够严谨）
当你以public方式继承时，基类Employee的public成员和protected成员会分别成为
派生类Manager的public和protected成员。
基类的private成员则不可直接访问，但它们依然存在于对象中，
并且可以通过基类的public或protected成员函数进行间接访问。